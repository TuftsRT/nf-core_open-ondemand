#!/usr/bin/env bash
# --------------------------------------------------------------
# nf-ood-mod.sh – Convert nf-core pipelines into OOD apps and Lmod modules
# --------------------------------------------------------------

set -euo pipefail        # abort on error, unset variable, or failed pipe
set +x                   # turn off trace (remove/comment if you want debugging)
IFS=$'\n\t'              # sane field separator for loops over file names

# --------------------------------------------------------------
# Helper: print an error message and exit
# --------------------------------------------------------------
die() {
    printf 'ERROR: %s\n' "$1" >&2
    exit 1
}

# -------------------------------------------------
# locate_schema <pipeline> <version>
# returns (echoes) the path to nextflow_schema.json or dies
# -------------------------------------------------
locate_schema() {
    local pipeline=$1
    local version=$2

    local underscore="${version//./_}"

    # candidate list (ordered by likeliness)
    local candidates=(
        "${input_dir}/${pipeline}/${version}/${underscore}/nextflow_schema.json"  # flat with underscore subdir
        "${input_dir}/${pipeline}/${version}/nextflow_schema.json"               # version dir directly
        "${input_dir}/${pipeline}/${underscore}/nextflow_schema.json"            # underscore dir directly
        "${input_dir}/${pipeline}/nextflow_schema.json"                          # pipeline root
    )

    local candidate
    for candidate in "${candidates[@]}"; do
        if [[ -f "$candidate" ]]; then
            printf '%s' "$candidate"
            return 0
        fi
    done

    die "Cannot find nextflow_schema.json for $pipeline $version (looked in: ${candidates[*]})"
}

# --------------------------------------------------------------
# generate_module – create a single Lmod module file from a template
# --------------------------------------------------------------
generate_module() {
    local pipeline=$1
    local ver=$2
    local output=$3

    local converted_version
    converted_version=$(printf '%s' "$ver" | tr '.' '_')

    local homepage=""       # (optional) could be used in the template
    local description=""

    local template_file="${TEMPLATE_DIR}/lmod_template.lua"
    [[ -f "$template_file" ]] || die "Template file '$template_file' not found."

    local modulefile_content
    modulefile_content=$(sed -e "s|\${PIPELINE}|$pipeline|g" \
                              -e "s|\${VERSION}|$ver|g" \
                              -e "s|\${VERSION_}|$converted_version|g" \
                              "$template_file")

    printf '%s\n' "$modulefile_content" > "$output"
}

# --------------------------------------------------------------
# Determine the repository root (used for locating templates, etc.)
# --------------------------------------------------------------
parentfolder=$(git rev-parse --show-toplevel)

# Default (empty) values for the command-line options
input_dir=""
output_dir=""
module_outdir=""

TEMPLATE_DIR="${parentfolder}/module_templates"

# --------------------------------------------------------------
# Parse command-line arguments
# --------------------------------------------------------------
while [[ $# -gt 0 ]]; do
    case "$1" in
        -i|--input)   input_dir=$2; shift 2 ;;
        -o|--output)  output_dir=$2; shift 2 ;;
        -m|--module)  module_outdir=$2; shift 2 ;;
        -h|--help)
            cat <<EOF
Usage: $(basename "$0") -i INPUT_DIR -o OUTPUT_DIR -m MODULE_OUTDIR
Convert nf-core pipelines into OOD apps.

  -i, --input   Directory that contains the nf-core pipelines
  -o, --output  Directory where the generated OOD apps will be placed
  -m, --module  Directory where the generated Lmod module files will be placed
  -h, --help    Show this help message and exit
EOF
            exit 0
            ;;
        *) die "Invalid argument: $1" ;;
    esac
done

# --------------------------------------------------------------
# Validate mandatory arguments
# --------------------------------------------------------------
[[ -n "$input_dir" ]]   || die "Missing required argument: --input"
[[ -n "$output_dir" ]]  || die "Missing required argument: --output"
[[ -n "$module_outdir" ]] || die "Missing required argument: --module"

# --------------------------------------------------------------
# Create (or optionally delete) the output directories
# --------------------------------------------------------------
prepare_dir() {
    local dir=$1
    local description=$2   # e.g. "output" or "module"

    if [[ -d "$dir" ]]; then
        printf "The %s folder already exists. Delete it and start fresh? (y/n) " "$description"
        read -r answer
        if [[ $answer == [Yy] ]]; then
            printf "Deleting existing %s folder…\n" "$description"
            rm -rf "$dir"
        else
            printf "Will reuse the existing %s folder.\n" "$description"
        fi
    fi
    mkdir -p "$dir"
}

prepare_dir "$output_dir"   "output"
prepare_dir "$module_outdir" "module"

# --------------------------------------------------------------
# Get the list of pipelines present in the input directory
# uses find for robustness
# --------------------------------------------------------------
[[ -d "$input_dir" ]] || die "Input directory '$input_dir' does not exist."

mapfile -t pipelines < <(find "$input_dir" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' | sort)

# --------------------------------------------------------------
# perform_sed_replacement – safe wrapper around `sed -i`
# Escapes delimiter characters in the replacement to avoid breaking sed.
# --------------------------------------------------------------
perform_sed_replacement() {
    local file=$1
    local pattern=$2
    local replacement=$3

    [[ -f "$file" ]] || die "File not found: $file"

    # escape delimiter @ and backslashes and ampersands in replacement
    local esc_replacement
    esc_replacement=$(printf '%s' "$replacement" | sed -e 's/[\/&@]/\\&/g' -e 's/\\/\\\\/g')

    sed -i -e "s@${pattern}@${esc_replacement}@g" "$file"
}

# --------------------------------------------------------------
# replace_placeholders – substitute various tokens inside the generated OOD files
# Now accepts templateFile path as a 6th parameter for cleanup
# --------------------------------------------------------------
replace_placeholders() {
    local PIPELINE=$1
    local VERSION=$2
    local OUTDIR=$3
    local FORM_YML=$4
    local PARAMS_JSON=$5
    local TEMPLATE_FILE=${6:-}   # optional

    local CONVERTED_VERSION="${VERSION//./_}"
    local COMBINED_VERSION="${VERSION}/${CONVERTED_VERSION}"
    local MYAPP="${OUTDIR##*/}"

    # Determine a subcategory for the manifest (used by OOD).
    # Updated from nf-co.re/pipelines.json (144 pipelines, 2026-02-18).
    case "$PIPELINE" in
        nf-core-abotyper|nf-core-diseasemodulediscovery|nf-core-drugresponseeval|nf-core-longraredisease|nf-core-meerpipe|\
        nf-core-oncoanalyser|nf-core-pacsomatic|nf-core-raredisease|nf-core-tumourevo|nf-core-variantprioritization)
            SUBCATEGORY="clinical" ;;
        nf-core-drop|nf-core-hadge|nf-core-marsseq|nf-core-mcmicro|nf-core-molkart|\
        nf-core-panoramaseq|nf-core-pixelator|nf-core-scdownstream|nf-core-scflow|nf-core-scnanoseq|\
        nf-core-scrnaseq|nf-core-smartseq2|nf-core-sopa|nf-core-spatialvi|nf-core-spatialxe)
            SUBCATEGORY="singlecell" ;;
        nf-core-alleleexpression|nf-core-cageseq|nf-core-circrna|nf-core-clipseq|nf-core-denovotranscript|\
        nf-core-differentialabundance|nf-core-dualrnaseq|nf-core-evexplorer|nf-core-isoseq|nf-core-lncpipe|\
        nf-core-nanostring|nf-core-nascent|nf-core-ribomsqc|nf-core-riboseq|nf-core-rnafusion|\
        nf-core-rnaseq|nf-core-rnasplice|nf-core-rnavar|nf-core-slamseq|nf-core-smrnaseq|\
        nf-core-spinningjenny|nf-core-tfactivity)
            SUBCATEGORY="rnaseq" ;;
        nf-core-atacseq|nf-core-callingcards|nf-core-chipseq|nf-core-cutandrun|nf-core-hic|\
        nf-core-hicar|nf-core-methylarray|nf-core-methylong|nf-core-methylseq|nf-core-mnaseseq|\
        nf-core-sammyseq|nf-core-ssds)
            SUBCATEGORY="epigenomics" ;;
        nf-core-ampliseq|nf-core-coproid|nf-core-createtaxdb|nf-core-detaxizer|nf-core-eager|\
        nf-core-funcscan|nf-core-mag|nf-core-magmap|nf-core-metapep|nf-core-metatdenovo|\
        nf-core-pathogensurveillance|nf-core-phageannotator|nf-core-proteinfamilies|nf-core-taxprofiler|nf-core-troughgraph|\
        nf-core-vipr|nf-core-viralintegration|nf-core-viralmetagenome|nf-core-viralrecon)
            SUBCATEGORY="metagenomics" ;;
        nf-core-ddamsproteomics|nf-core-diaproteomics|nf-core-mhcquant|nf-core-proteinannotator|nf-core-proteinfold|\
        nf-core-proteogenomicsdb|nf-core-proteomicslfq|nf-core-quantms)
            SUBCATEGORY="proteomics" ;;
        nf-core-metaboigniter)
            SUBCATEGORY="metabolomics" ;;
        nf-core-cellpainting|nf-core-imcyto|nf-core-liverctanalysis|nf-core-lsmquant|nf-core-rangeland)
            SUBCATEGORY="imaging" ;;
        nf-core-airrflow|nf-core-epitopeprediction|nf-core-hlatyping)
            SUBCATEGORY="immunology" ;;
        nf-core-bacass|nf-core-bactmap|nf-core-circdna|nf-core-createpanelrefs|nf-core-crisprseq|\
        nf-core-crisprvar|nf-core-deepmodeloptim|nf-core-deepmutscan|nf-core-deepvariant|nf-core-denovohybrid|\
        nf-core-exoseq|nf-core-genomeannotator|nf-core-genomeassembler|nf-core-genomeqc|nf-core-genomeskim|\
        nf-core-genomicrelatedness|nf-core-gwas|nf-core-hgtseq|nf-core-mitodetect|nf-core-multiplesequencealign|\
        nf-core-neutronstar|nf-core-omicsgenetraitassociation|nf-core-pacvar|nf-core-pairgenomealign|nf-core-pangenome|\
        nf-core-phaseimpute|nf-core-phyloplace|nf-core-radseq|nf-core-rarevariantburden|nf-core-references|\
        nf-core-reportho|nf-core-rnadnavar|nf-core-sarek|nf-core-seqinspector|nf-core-stableexpression|\
        nf-core-tbanalyzer|nf-core-variantbenchmarking|nf-core-variantcatalogue)
            SUBCATEGORY="genomics" ;;
        nf-core-bamtofastq|nf-core-datasync|nf-core-demo|nf-core-demultiplex|nf-core-fastqrepair|\
        nf-core-fastquorum|nf-core-fetchngs|nf-core-kmermaid|nf-core-nanoseq|nf-core-readsimulator|\
        nf-core-seqsubmit)
            SUBCATEGORY="utility" ;;
        nf-core-*) SUBCATEGORY="${PIPELINE#nf-core-}" ;;
        *) SUBCATEGORY="unknown" ;;
    esac

    # Apply the replacements
    perform_sed_replacement "${OUTDIR}/submit.yml.erb"    "PIPELINE"   "$PIPELINE"
    perform_sed_replacement "${OUTDIR}/manifest.yml"    "PIPELINE"   "${PIPELINE##*-}"
    perform_sed_replacement "$FORM_YML"    "PIPELINE"   "${PIPELINE##*-}"
    perform_sed_replacement "$FORM_YML"    "VERSION"    "$VERSION"
    perform_sed_replacement "${OUTDIR}/manifest.yml"    "VERSION"    "$VERSION"
    perform_sed_replacement "${OUTDIR}/template/script.sh.erb" "VERSION" "${COMBINED_VERSION}"
    perform_sed_replacement "${OUTDIR}/template/script.sh.erb" "PIPELINE" "$PIPELINE"
    perform_sed_replacement "$FORM_YML"                  "PIPELINE"   "$PIPELINE"
    perform_sed_replacement "${OUTDIR}/manifest.yml"    "MYAPP"      "$MYAPP"
    perform_sed_replacement "${OUTDIR}/manifest.yml"    "SUBCATEGORY" "$SUBCATEGORY"

    # Small clean-ups
    sed -i '/- igenomes_base/d' "$FORM_YML"
    sed -i "s/value: True/value: true/g"  "$FORM_YML"
    sed -i "s/value: False/value: false/g" "$FORM_YML"

    # Update the default value for `igenomes_base` inside the params JSON
    sed -i -e "s|\<%= context\.igenomes_base %\>|/cluster/tufts/biocontainers/datasets/igenomes|g" "$PARAMS_JSON"

    # Remove the generic template file if provided
    if [[ -n "$TEMPLATE_FILE" && -f "$TEMPLATE_FILE" ]]; then
        rm -f "$TEMPLATE_FILE"
    fi
}

# --------------------------------------------------------------
# generate_pipeline – build an OOD app and its Lmod module for one pipeline/version
# --------------------------------------------------------------
generate_pipeline() {
    local PIPELINE=$1
    local VERSION=$2

    printf "Generating OOD app and modules for %s v%s\n" "$PIPELINE" "$VERSION"

    # -----------------------------------------------------------------
    # 1️⃣  Determine where the schema lives
    # -----------------------------------------------------------------
    local inputJson
    inputJson=$(locate_schema "$PIPELINE" "$VERSION")   # will echo path or die

    # -----------------------------------------------------------------
    # 2️⃣  Rest of the function (unchanged, just use $inputJson)
    # -----------------------------------------------------------------
    local CONVERTED_VERSION="${VERSION//./-}"
    local OUTDIR="${output_dir}/${PIPELINE}-${CONVERTED_VERSION}"
    cp -r "${parentfolder}/nfcore_ood_template" "$OUTDIR"

    local formYmlOut="${OUTDIR}/form.yml.erb"
    local templateFile="${OUTDIR}/form.template.erb"
    local paramsJsonOut="${OUTDIR}/template/nf-params.json.erb"

    python "${parentfolder}/json2ood.py" "$inputJson" "$formYmlOut" "$templateFile" "$paramsJsonOut"

    replace_placeholders "$PIPELINE" "$VERSION" "$OUTDIR" "$formYmlOut" "$paramsJsonOut" "$templateFile"

    mkdir -p "${module_outdir}/${PIPELINE}"
    generate_module "$PIPELINE" "$VERSION" "${module_outdir}/${PIPELINE}/${VERSION}.lua"
}

# --------------------------------------------------------------
# MAIN – iterate over every pipeline and every version it contains
# uses find() for versions too
# --------------------------------------------------------------
for PIPELINE in "${pipelines[@]}"; do
    printf "Processing pipeline: %s\n" "$PIPELINE"

    # List the version directories for this pipeline (ignore hidden dirs)
    mapfile -t version_array < <(find "${input_dir}/${PIPELINE}" -mindepth 1 -maxdepth 1 -type d ! -name '.*' -printf '%f\n' | sort)

    for VERSION in "${version_array[@]}"; do
        # Skip internal folders or malformed version names (e.g., .nextflow, _work)
        if [[ ! "$VERSION" =~ ^[0-9] ]]; then
            printf "Skipping non-version folder: %s/%s\n" "$PIPELINE" "$VERSION"
            continue
        fi

        generate_pipeline "$PIPELINE" "$VERSION"
    done
done

# --------------------------------------------------------------
# End of script
# --------------------------------------------------------------
